# Script that parses the Doxygen command help page
# https://www.doxygen.nl/manual/commands.html,
# extracts the documentation for each command and
# generates a C# file that exposes the information.

import bs4
import os
from datetime import datetime
import re
from enum import Enum
from typing import Union


class FragmentType(Enum):
    Text = 1
    Code = 2
    Emphasis = 3
    Note = 4
    Warning = 5


# class Fragment:
#     def __init__(self, type: FragmentType, content):
#         self.type = type
#         self.content: list[Union[str, Fragment]] = content

class Fragment:
    def __init__(self, type: FragmentType, content: str):
        self.type = type
        self.content = content



# def unify_fragments(fragments):
#     if len(fragments) == 0:
#         return []
#     if len(fragments) == 1 and len(fragments[0].content) == 1:
#         return fragments

#     unified = [Fragment(fragments[0].type, unify_fragments(fragments[0].content))]
#     for idx in range(1, len(fragments)):
#         prev_fragment = unified[-1]
#         cur_fragment = fragments[idx]
#         if prev_fragment.type == cur_fragment.type:
#             new_content = prev_fragment.content
#             new_content.extend(cur_fragment.content)
#             prev_fragment.content = unify_fragments(new_content)
#         else:
#             f = Fragment(cur_fragment.type, unify_fragments(cur_fragment.content))
#             unified.append(f)
    
#     return unified
    

class ParsedCommand:
    def __init__(self, header: str, help_text: list[Fragment]):
        assert(len(header) > 0)
        self.raw_header = header
        self.help_text = help_text

        if header[0] != "\\":
            raise Exception(f"Header does not start with '\\': {header}")
        (self.command, self.parameters) = split_command_header(header)

        self.escaped_command = escape_characters(self.command)
        self.escaped_parameters = escape_characters(self.parameters)
        self.escaped_help_text = [Fragment(f.type, escape_characters(f.content)) for f in self.help_text]


def escape_characters(raw_string: str):
    return raw_string.replace("\\", "\\\\").replace('"', '\\"').replace("\r", "").replace("\n", "\\n")


def split_command_header(header: str):
    # Split the header into command and parameter. For example:
    #    \example['{lineno}'] <file-name>
    #    \file [<name>]
    space_pos = header.find(" ")
    if space_pos == -1:
        space_pos = len(header)

    square_bracket_pos = header.find("[")
    if square_bracket_pos == -1:
        square_bracket_pos = len(header)

    if square_bracket_pos < space_pos:
        cmd_end_pos = square_bracket_pos
        param_start_pos = square_bracket_pos
    else:
        cmd_end_pos = space_pos
        param_start_pos = min(space_pos + 1, len(header))

    command = header[1:cmd_end_pos]
    parameters = header[param_start_pos:]
    return (command, parameters)



def parse_doxygen_help_html(file) -> list[ParsedCommand]:
    soup = bs4.BeautifulSoup(file, 'html.parser')
    
    all_parsed_commands: list[ParsedCommand] = []

    # The actual descriptions start at the first <h1> tag after the first <center> tag.
    tag = soup.find("center")
    tag = tag.find_next_sibling("h1")

    while tag != None:
        header_tag = tag
        tag = tag.next_sibling
        description_tags = []

        # The description of one Doxygen command continues until the next <h1> tag.
        while tag != None and tag.name != "h1":
            description_tags.append(tag)
            tag = tag.next_sibling
        
        parsed = parse_html_tags_of_single_command(header_tag, description_tags)
        all_parsed_commands.append(parsed)

    return all_parsed_commands
        

def parse_recursive(tag: bs4.element.PageElement, decorator) -> list[Fragment]:
    if isinstance(tag, bs4.element.Comment):
        return []

    elif isinstance(tag, str):
        return [Fragment(FragmentType.Text, decorator(tag))]

    elif tag.name == "p":
        fragments = parse_all_children(tag.children, lambda x: decorator(x).replace("\r", "").replace("\n", ""))
        fragments = merge_fragments(fragments)
        if len(fragments) > 0:
            fragments[0].content = fragments[0].content.lstrip(" ")

            s = fragments[-1].content.rstrip(" ")
            fragments[-1].content = s
            if s == "Click here  for the corresponding HTML documentation that is generated by doxygen.":
                fragments = fragments[:-1]
            elif s == "Go to the next section or return to the index.":
                fragments = fragments[:-1]
            elif tag.next_sibling.name != "ul":
                fragments.append(Fragment(FragmentType.Text, "\n"))

        return fragments

    elif tag.name == "code":
        s = parse_all_children_assuming_only_text(tag.children, decorator)
        return [Fragment(FragmentType.Code, s)]

    elif tag.name == "em":
        s = parse_all_children_assuming_only_text(tag.children, decorator)
        return [Fragment(FragmentType.Emphasis, s)]

    elif tag.name == "dl" and ' '.join(tag['class']) == "section see":
        if len(tag.contents) != 2:
            raise Exception("Expected the 'section see' to always have exactly 2 children.")
        see_also_fragments = parse_all_children(tag.contents[1:], decorator)
        if len(see_also_fragments) == 0:
            return []

        for idx in range(0, len(see_also_fragments)):
            # The documentation often has something like "See also: Section \page for an example"
            # which reads weird in the Visual Studio tooltip, since one cannot click there. So 
            # replace "section" with "command". But not the \section command itself.
            see_also_fragments[idx].content = re.sub(r"\b(?<!\\)section\b", "command", see_also_fragments[idx].content)
            see_also_fragments[idx].content = re.sub(r"\b(?<!\\)Section\b", "Command", see_also_fragments[idx].content)
            see_also_fragments[idx].content = re.sub(r"\b(?<!\\)sections\b", "commands", see_also_fragments[idx].content)
            see_also_fragments[idx].content = re.sub(r"\b(?<!\\)Sections\b", "Commands", see_also_fragments[idx].content)
        
        see_also_fragments[0].content = see_also_fragments[0].content.lstrip()
        see_also_fragments[-1].content = see_also_fragments[-1].content.rstrip()

        see_also_fragments.insert(0, Fragment(FragmentType.Text, "See also: "))
        see_also_fragments.append(Fragment(FragmentType.Text, "\n"))
        
        return see_also_fragments

    elif tag.name == "dl" and ' '.join(tag['class']) in ["section note", "section warning"]:
        tag_class = ' '.join(tag['class'])

        fragments = []

        if tag.previous_sibling != "\n":
            fragments.append(Fragment(FragmentType.Text, "\n"))

        if "note" in tag_class:
            fragments.append(Fragment(FragmentType.Note, "Note:"))
        else:
            fragments.append(Fragment(FragmentType.Warning, "Warning:"))

        if len(tag.contents) > 2:
            for child in filter(lambda x: x != "\n", tag.contents[1:]):
                child_fragments = parse_all_children([child], decorator)
                if len(child_fragments) > 0:
                    child_fragments[0].content = "\n\t" + child_fragments[0].content.lstrip()
                    child_fragments[-1].content = child_fragments[-1].content.rstrip()
                    fragments.extend(child_fragments)
        else:
            children_fragments = parse_all_children(tag.contents[1:], decorator)
            if len(children_fragments) > 0:
                children_fragments[0].content = " " + children_fragments[0].content.lstrip()
                children_fragments[-1].content = children_fragments[-1].content.rstrip()
                fragments.extend(children_fragments)

        fragments.append(Fragment(FragmentType.Text, "\n"))
        return fragments

    elif tag.name == "dl" and ' '.join(tag['class']) == "section user":
        # Either some example code, or some note
        fragments = parse_all_children(tag.children, decorator)
        fragments.append(Fragment(FragmentType.Text, "\n"))
        return fragments

    elif tag.name == "dt":
        fragments = parse_all_children(tag.children, decorator)
        fragments.append(Fragment(FragmentType.Text, " "))
        return fragments

    elif tag.name == "dd":
        fragments = merge_fragments(parse_all_children(tag.children, decorator))
        filtered_fragments = [f for f in fragments if f.content.strip() != "Click here\n  for the corresponding HTML documentation that is generated by doxygen."]
        if len(fragments) != len(filtered_fragments) and len(filtered_fragments) > 0:
            filtered_fragments[-1].content = filtered_fragments[-1].content.rstrip()
        return filtered_fragments

    elif tag.name == "pre" or (tag.name == "div" and ' '.join(tag['class']) == "fragment") or tag.name == "blockquote":
        # Some code
        s = tag.get_text().strip("\n")
        lines = [("   " + l) for l in s.split("\n")]
        concat_lines = "\n".join(lines) + "\n\n"
        if tag.previous_sibling != "\n":
            concat_lines = "\n" + concat_lines
        return [Fragment(FragmentType.Code, concat_lines)]

    elif tag.name == "ul":
        fragments = parse_all_children(tag.children, decorator)
        if len(fragments) > 0 and len(fragments[-1].content) > 0 and fragments[-1].content[-1] == "\n":
            fragments[-1].content = fragments[-1].content.rstrip("\n") + "\n"
        return fragments

    elif tag.name == "li":
        stars = ""
        spaces = ""
        for parent in tag.parents:
            if parent.name == "ul":
                stars += "â€¢"
                spaces += "  "
        
        fragments = parse_all_children(tag.children, decorator)
        fragments[0].content = spaces + stars + " " + fragments[0].content.lstrip()

        # Removes successive newlines between list elements. For example for the "\showdate" command.
        if fragments[-1].content[-1] == "\n":
            while fragments[-1].content[-1] == "\n":
                fragments[-1].content = fragments[-1].content.rstrip("\n")
                fragments = merge_fragments(fragments)
            if tag.next_sibling == None or tag.next_sibling != "\n":
                fragments.append(Fragment(FragmentType.Text, "\n"))

        return fragments

    elif tag.name == "table":
        return parse_table(tag)

    elif tag.name == "img":
        if "LaTeX" in tag["alt"]:
            return [Fragment(FragmentType.Text, "LaTeX")]
        else:
            raise Exception("Unknown image")
        
    elif tag.name == "center":
        # The "center" tag is only used for the "intermediate" headers like "Commands for displaying examples"
        # that separate the different command categories. We don't want them.
        return []

    else:
        return parse_all_children(tag.children, decorator)


def parse_all_children(children, decorator) -> list[Fragment]:
    fragments = []
    for child in children:
        fragments.extend(parse_recursive(child, decorator))
    return fragments


def parse_all_children_assuming_only_text(children, decorator) -> str:
    fragments = parse_all_children(children, decorator)
    s = ""
    for fragment in fragments:
        if fragment.type != FragmentType.Text:
            raise Exception("Expected only text fragments")
        s += fragment.content
    return s


def parse_table(table: bs4.element.Tag) -> list[Fragment]:
    table_contents = [x for x in filter(lambda x: x != "\n", table.contents)]
    if len(table_contents) != 1:
        raise Exception("Expected table to contain only a single tag")
    body_tag = table_contents[0]
    if body_tag.name != "tbody":
        raise Exception("Expected table to contain 'tbody'")
    
    t = body_tag.contents[0]
    rows = []
    while t != None:
        if t != "\n":
            columns = []
            for column_tag in t.children:
                if column_tag != "\n":
                    column_text = column_tag.get_text().strip()
                    columns.append(column_text)
            rows.append(columns)
        t = t.next_sibling

    column_widths = [0 for c in rows[0]]
    for row in rows:
        if len(row) != len(column_widths):
            raise Exception("Table has different number of columns in its rows")
        for column_index in range(0, len(row)):
            column_widths[column_index] = max(column_widths[column_index], len(row[column_index]))

    # Insert a separator between the header and the table content. The first row is assumed to be the header
    rows.insert(1, ["-" * column_widths[idx] for idx in range(0, len(column_widths))])

    header_row_prefix = "    "
    column_separator = "  "

    s = ""
    for row in rows:
        s += header_row_prefix
        for column_index in range(0, len(row)):
            s += row[column_index].ljust(column_widths[column_index], " ")
            if column_index != len(row)-1:
                s += column_separator
        s += "\n"
    return [Fragment(FragmentType.Text, s)]


def parse_html_tags_of_single_command(header_tag, description_tags):
    description_text = []

    for desc_tag in description_tags:
        fragments = parse_recursive(desc_tag, lambda x: x)
        description_text.extend(fragments)

    # Remove whitespace at the start and end and merge fragments as much as possible
    while len(description_text) > 0:
        description_text[0].content = description_text[0].content.lstrip()
        description_text[-1].content = description_text[-1].content.rstrip()
        new_fragments = merge_fragments(description_text)
        if len(new_fragments) == len(description_text):
            break
        description_text = new_fragments

    header_text = header_tag.get_text().strip()
    return ParsedCommand(header_text, description_text)


def merge_fragments(fragments: list[Fragment]) -> list[Fragment]:
    if len(fragments) == 0:
        return []

    new_list = [fragments[0]]
    for idx in range(1, len(fragments)):
        f = fragments[idx]
        if f.type == new_list[-1].type:
            new_list[-1].content += f.content
        else:
            new_list.append(f)

    new_list = [f for f in new_list if len(f.content) > 0]
    return new_list


def generate_text_for_csharp_file(commands: list[ParsedCommand]) -> str:
    python_file = os.path.basename(__file__)
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    max_command_len, max_parameters_len = get_max_component_lengths(commands)

    s = f"// This file was automatically generated by the Python script\n"
    s += f"// {python_file} on {current_time}.\n\n"

    s += "namespace VSDoxyHighlighter\n"
    s += "{\n"
    s += "  class DoxygenCommandsGeneratedFromHelpPage\n"
    s += "  {\n"
    s += "    public static readonly DoxygenHelpPageCommand[] cCommands = {\n"

    for cmd in commands:
        command_padding = " " * (max_command_len - len(cmd.escaped_command))
        parameters_padding = " " * (max_parameters_len - len(cmd.escaped_parameters))
        help_text = fragment_list_to_string_for_debug(cmd.escaped_help_text)
        s += f'      new DoxygenHelpPageCommand("{cmd.escaped_command}",{command_padding} "{cmd.escaped_parameters}",{parameters_padding} "{help_text}"),\n'

    s += "    };\n"
    s += "  }\n"
    s += "}\n"

    return s


def generate_debug_dump(commands: list[ParsedCommand]) -> str:
    s = ""
    for cmd in commands:
        s += "====================================\n"
        s += f"Command: {cmd.command}\n"
        s += f"Parameters: {cmd.parameters}\n"
        s += f"Help text:\n{fragment_list_to_string_for_debug(cmd.help_text)}\n"
        s += "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n\n"
    return s


# def fragment_list_to_string_for_debug(fragments: list[Fragment]) -> str:
#     s = ""
#     for f in fragments:
#         if f.type == FragmentType.Text:
#             s += f.content
#         elif f.type == FragmentType.Code:
#             s += f"```{f.content}```"
#         elif f.type == FragmentType.Emphasis:
#             s += f"**{f.content}**"
#         elif f.type == FragmentType.Note:
#             s += f"!{f.content}!"
#         elif f.type == FragmentType.Warning:
#             s += f"!!!{f.content}!!!"
#         else:
#             raise Exception("Unknown FragmentType")
#     return s
def fragment_list_to_string_for_debug(fragments: list[Fragment]) -> str:
    s = ""
    for f in fragments:
        if f.type == FragmentType.Text:
            s += f.content
        elif f.type == FragmentType.Code:
            s += f.content
        elif f.type == FragmentType.Emphasis:
            s += f"**{f.content}**"
        elif f.type == FragmentType.Note:
            s += f.content
        elif f.type == FragmentType.Warning:
            s += f.content
        else:
            raise Exception("Unknown FragmentType")
    return s


def get_max_component_lengths(commands: list[ParsedCommand]):
    command_len = 0
    parameters_len = 0
    for cmd in commands:
        command_len = max(command_len, len(cmd.escaped_command))
        parameters_len = max(parameters_len, len(cmd.escaped_parameters))
    return (command_len, parameters_len)


def extract_and_convert_doxygen_commands_from_html(html_filename: str, output_csharp_filename: str, output_debug_dump_filename: str):
    with open(html_filename, 'r', encoding='utf-8') as input_file:
        parsed_commands = parse_doxygen_help_html(input_file)
    
    csharp_text = generate_text_for_csharp_file(parsed_commands)
    with open(output_csharp_filename, 'w', encoding='utf-8') as output_file:
        output_file.write(csharp_text)

    dump_text = generate_debug_dump(parsed_commands)
    with open(output_debug_dump_filename, 'w', encoding='utf-8') as output_file:
        output_file.write(dump_text)


if __name__ == "__main__":
    extract_and_convert_doxygen_commands_from_html(
        "VSDoxyHighlighter/DoxygenHelpPageParser/testInput.htm", 
        "VSDoxyHighlighter/DoxygenHelpPageParser/DoxygenCommandsGeneratedFromHelpPage.cs",
        "VSDoxyHighlighter/DoxygenHelpPageParser/GeneratedDebugDump.txt")
